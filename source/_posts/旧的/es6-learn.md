---
title: es6-learn
date: 2019-03-23 10:00:39
tags:
---
E6的块级绑定

所声明的变量在指定的作用域外无法访问

| let                            | var      | const                              |
| ------------------------------ | -------- | ---------------------------------- |
| 不变量提升,块级作用域          | 变量提升 | 不变量提升,块级作用域              |
| 重复禁止声明                   |          | 重复禁止声明                       |
| let 声明的变量成为window的属性 |          | 设置完成后不能被改变               |
|                                |          | JS所声明的常量对象属性的值可以改变 |

暂时性死区：

在使用let 或者const 声明的变量，在达到声明处之前访问变量都是无法访问的,访问会导致一个引用错误

ES6模块

由于JS共享一切的特性,容易产生命名冲突.安全等问题,代码的模块划分很有必要

| 模块加载方式                                       | JS脚本加载方式 |
| -------------------------------------------------- | -------------- |
| 严格模式下运行                                     |                |
| 模块顶级作用域创建的变量不会自动添加到全局作用域中 |                |
| 顶级作用域this 为undefinde                         |                |
| 对于需要让模块外部访问的代码内容，模块必须导出他们 |                |

导出的方式

| export                                             | 相对应的导入                                                 |
| -------------------------------------------------- | ------------------------------------------------------------ |
| 导出的函数，类必修有名字 export  {aaa};            | import {aaa} from xxx;                                       |
|                                                    | 命名空间导入:完全导入一个模块,import * as	 example	 from "./example.js"; example.sum() |
| 重命名导出： export	{	sum	as	add	}; | 重命名导入 import	{	add	as	sum	}	from	"./example.js"; |

默认导出

| 导出默认值            | 导入默认值                               |
| --------------------- | ---------------------------------------- |
| export  default  xxx; | import	sum	from	"./example.js"; |

加载模块

| script 外部加载                        | script 脚本加载 |
| -------------------------------------- | --------------- |
| type="module" src="example.js"         |                 |
| **script 行内加载**                    |                 |
| import {sum} from ''                   |                 |
| 按顺序执行加载，像应用了defer 的script |                 |

函数

剩余参数...arg,扩展运算符

箭头函数--解决this 的追踪问题

| 箭头函数                               | 普通函数 |
| -------------------------------------- | -------- |
| 没有this super argument ,没有this 绑定 |          |
| 不能被new 调用                         |          |
| 不能更改this,没有arguments 对象        |          |

## Set 和Map

| set                                                          | weakSet                                 |
| ------------------------------------------------------------ | --------------------------------------- |
| 不包含重复值的有序列表                                       | 自动解除set中得引用，如果其他引用没有了 |
| new set([arr]） set.size  set.add(value) set.has(value)  set.delete(value) set.clear(); | 初始化只能接受对象得值                  |
| forEach((value,key,ownset)=>{}) 按顺序处理每一项             | 无size ,forEach,迭代器得方法也没有      |
| 转换为数组:let	set	=	new	Set([1,	2,	3,	3,	3,	4,	5]),				array	=	[...set]; |                                         |
|                                                              |                                         |
|                                                              |                                         |



| Map                                                          | weakMap |
| ------------------------------------------------------------ | ------- |
| 键值对有序列表,键和值都是任意类型得                          |         |
| map.set("","")  map.get("") map.size                         |         |
| has() delete()  clear                                        |         |
| 初始化:let  map	=	new	Map([["name",	"Nicholas"],	["age",	25]]); 双数组 |         |
| forEach                                                      |         |
|                                                              |         |


